# -*- coding: utf-8 -*-
"""Comp Phy sheet 1 #1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WyE9CAoZoUMj6v1jTZlwg19qHEkBZ86U
"""

# Commented out IPython magic to ensure Python compatibility.
#discreteization
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

pi = np.pi
fig = plt.figure(figsize=(9,7))
ax  = fig.add_subplot(111)
ax.set_title("Discretization example.")
ax.set_xlabel(r'x')
ax.set_ylabel(r'2cos(x^2)-1')
#creating f(x)
def f_n(x):
  return 2 * np.cos(x ** 2) - 1
#creating xi

def x_n(i):
  return np.array([-1 + (2 * (i+.5)/N) for i in range (N)])

#array of numbers
N_array = np.array([2,5,10,100,1000])

#making the range of the plot
start = -1
stop = 1

for N in N_array:
  x = x_n(N) # getting the x values to plot
  y = f_n(x) #using f(x) function to plot y
  ax.plot(x,y, 'o--', label = f'N = {N}', markersize = '.1')
# making labels and setting markers smalle enough to see difference

ax.legend()

# Commented out IPython magic to ensure Python compatibility.
#manual interpol
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

#creating f(x)
def f_n(x):
  return (2 * np.cos(x ** 2)) - 1
#creating xi

def x_n(N):
  return np.array([-1 + (2 * (i+.5)/N) for i in range (N)])

#array of numbers
N_array = np.array([2,5,10,100,1000])


#Finding the point to interpolate

x = float(input("Enter the value of x: "))


def interpl_funct (x_n,x,f_n):
  y = f_n(x_n)

  for i in range (len(x_n)-1):
    if x_n[i] <= x < x_n[i+1] :   #< x_n[i+1] : #findng the two points
      interp_data = y[i] + (x - x_n[i]) * (y[i+1] - y[i]) / (x_n[i+1] - x_n[i])
      return interp_data

      #usuing the interpolation formula
N = N_array[-1]
x_i = x_n(N)
interpolation = interpl_funct(x_i,x,f_n)
print(interpolation)

# Commented out IPython magic to ensure Python compatibility.
#interpol function
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

#creating f(x)
def f_n(x):
  return 2 * np.cos(x ** 2) - 1
#creating xi

def x_n(N):
  return np.array([-1 + (2 * (i+.5)/N) for i in range (N)])

#array of numbers
N = np.array([2,5,10,100,1000])

#Finding the point to interpolate
x = float(input("Enter the value of x: "))

#using built in interp funct
def interpl_funct (x_n,x,f_n):
  interp1d = np.interp(x,x_n,f_n(x_n))
  return interp1d
print(f_n(interpl_funct(x_n(2),x,f_n)))

#inverse function
import numpy as np
from scipy import interpolate

#creating f(x)
def f_n(x):
  return 2 * np.cos(x ** 2) - 1
#creating xi

def x_n(N):
  return np.array([-1 + (2 * (i+.5)/N) for i in range (N)])

#setting N = 1000 ti simplify code for inverse funct
N = 1000

x_i = x_n(N)
y_i = f_n(x_i)

#Finding the point to interpolate
y = input("Enter the value of f(x) = : ")
y = y.replace(" ","")
y = float(y)

#had a probelm where interpolate wouldnt run when y had ducplicates as a trig fuctnion does
y_i, indicies = np.unique (y_i, return_index= True)
x_i= x_i[indicies] #setting the indiceies to the same as y

inverse = interpolate.interp1d(y_i, x_i, kind = 'cubic', fill_value = "extrapolate")

x_vals = inverse(y)
x2_vals = -1* x_vals

print(f"When f(x) = {y}, x = {x_vals} and x = {x2_vals}")

# Commented out IPython magic to ensure Python compatibility.
#derivative code
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

pi = np.pi
fig = plt.figure(figsize=(9,7))
ax  = fig.add_subplot(111)
ax.set_title("Derivative example.")
ax.set_xlabel(r'x')
ax.set_ylabel(r'2cos(x^2)-1')
#creating f(x)
def f_n(x):
  return 2 * np.cos(x ** 2) - 1
#creating xi

def x_n(N):
  return np.array([-1 + (2 * (i+.5)/N) for i in range (N)])

#array of numbers
N_array = np.array([2,5,10,100,1000])

for N in N_array:
  x = x_n(N) # getting the x values to plot
  y = f_n(x) #using f(x) function to plot y
  ax.plot(x,y,  label = f'Step = {N}', markersize = '1')

  dy = np.zeros_like(y)
  dy[1:-1] = (y[2:] - y[:-2]) / (x[2:] - x[:-2])# middle dif
  dy[0] = (y[1]- y[0] / (x[-1] - x[-2])) #forward
  dy[-1] = (y[-1] - y[-2]) / (x[-1] - x[-2]) #revrese
  ax.plot(x,dy,  label = f' Derivative Step = {N}', markersize = '1')




ax.set_ylim([-5,5])
ax.set_xlim([-5,5])
ax.legend()

#Integration using trapazoid rule
import math
import numpy as np
import matplotlib.pyplot as plt


pi = np.pi
fig = plt.figure(figsize=(9,7))
ax  = fig.add_subplot(111)
ax.set_title("Integral example.")
ax.set_xlabel(r'x')
ax.set_ylabel(r'2cos(x^2)-1')

#creating f(x)
def f_n(x):
  f_n = 2 * np.cos(x ** 2) - 1
  return f_n

#creating xi
def x_n(N):
  x_n = np.array([-1 + (2 * (i+.5)/N) for i in range (N)])
  return x_n

#I ran into issues with my array here so i set N to be as acurate as possible and chose 1000, as I understand the more point the better the graph

N = 500
x = x_n(N) # getting the x values to plot
y = f_n(x)

def integrate(x,y):
  N = len(x)
  y_int = np.zeros(N)

  for i in range(1,N):
    dx = x[i] - x[i-1] # trapaziodal rule
    y_int[i] = y_int[i-1] + (y[i] + y[i-1])/2 * dx #algebriac trap rule

  return y_int

y_int = integrate(x,y) #calling the integrate function


ax.plot(x,y_int,  label = f'integrated function', markersize = '1') #plotting vs regular funct





ax.plot(x,y,  label = f'2cos(x ** 2) - 1', markersize = '1')

ax.legend()

# Commented out IPython magic to ensure Python compatibility.
#integrating using method 2

import numpy as np
import matplotlib.pyplot as plt
from scipy import integrate
# %matplotlib inline

pi = np.pi
fig = plt.figure(figsize=(9,7))
ax  = fig.add_subplot(111)
ax.set_title("Discretization example.")
ax.set_xlabel(r'x')
ax.set_ylabel(r'2cos(x^2)-1')

#creating f(x)
def f_n(x):
  f_n = 2 * np.cos(x ** 2) - 1
  return f_n

#creating xi
def x_n(i):
  x_n = np.array([-1 + (2 * (i+.5)/N) for i in range (N)])
  return x_n

#array of numbers
N_array = np.array([2,5,10,100,1000])


for N in N_array:
  x = x_n(N) # getting the x values to plot
  y = f_n(x) #using f(x) function to plot y
  ax.plot(x,y,  label = f'2cos(x^2)-1 N = {N}', markersize = '.1')
# making labels and setting markers smalle enough to see difference

  integ = integrate.cumtrapz(y,x, initial = 0)
  ax.plot(x,integ, label = f'Integral N = {N}', markersize = '.1')
ax.legend()